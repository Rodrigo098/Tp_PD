Index: ../TP_PD_cliente_m1/src/pt/isec/pd/trabalhoPratico/model/classesPrograma/ProgramaCliente.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package pt.isec.pd.trabalhoPratico.model.classesPrograma;\r\n\r\nimport javafx.beans.InvalidationListener;\r\nimport javafx.beans.property.SimpleIntegerProperty;\r\nimport javafx.beans.property.SimpleStringProperty;\r\nimport javafx.util.Pair;\r\nimport pt.isec.pd.trabalhoPratico.model.classesComunication.*;\r\nimport pt.isec.pd.trabalhoPratico.model.recordDados.Evento;\r\nimport pt.isec.pd.trabalhoPratico.model.recordDados.Utilizador;\r\n\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.time.LocalDate;\r\nimport java.time.LocalTime;\r\nimport java.util.*;\r\n\r\n///////////////////////////////////// PROGRAMA CLIENTE ///////////////////////\r\npublic class ProgramaCliente {\r\n    // TEMPO\r\n    private static final int TEMPO_MAXIMO = 20; // 10 segundos\r\n    private final Timer temporizador = new Timer();\r\n    private int contagem = 0;\r\n    private TimerTask tarefa;\r\n    private boolean terminou = false;\r\n\r\n    // EVENTOS\r\n    private static final SimpleIntegerProperty atualizacao = new SimpleIntegerProperty(0);\r\n    private static final SimpleIntegerProperty erro = new SimpleIntegerProperty(0);\r\n    private static final SimpleStringProperty logado = new SimpleStringProperty(\"\");\r\n\r\n    // COMUNICAÇÃO\r\n    private Socket socket;\r\n    private int portoServidor;\r\n    private ObjectOutputStream oout;\r\n    private ObjectInputStream oin;\r\n    private boolean termina;\r\n\r\n    //-------------------- ATUALIZACAO ASSINCRONA -----------------\r\n    static class AtualizacaoAsync implements Runnable {\r\n        private MulticastSocket multicastSocket;\r\n        private InetAddress gClientes;\r\n        public AtualizacaoAsync(int porto, String multicastAddress) {\r\n            try {\r\n                this.multicastSocket = new MulticastSocket(porto);\r\n                gClientes = InetAddress.getByName(multicastAddress);\r\n                multicastSocket.joinGroup(gClientes);\r\n            } catch (IOException e) {\r\n                setErro();\r\n                setLogado(\"FIM\");\r\n            }\r\n        }\r\n        @Override\r\n        public void run() {\r\n            String msgConteudo;\r\n            while (logado.getValue().equals(\"ADMINISTRADOR\") || logado.getValue().equals(\"ADMINISTRADOR\")) {\r\n                DatagramPacket packet = new DatagramPacket(new byte[20], 20);\r\n                try {\r\n                    multicastSocket.receive(packet);\r\n                } catch (IOException e) {\r\n                    setErro();\r\n                }\r\n                msgConteudo = new String(packet.getData(), 0, packet.getLength());\r\n                if (msgConteudo.equals(\"fimServidor\")) {\r\n                    setLogado(\"FIM\");\r\n                    break;\r\n                }\r\n                else {\r\n                    atualizacao.setValue(atualizacao.getValue() + 1);\r\n                    System.out.println(\"mais uma \" + atualizacao.getValue());\r\n                }\r\n            }\r\n            try {\r\n                multicastSocket.leaveGroup(gClientes);\r\n            } catch (IOException e) {\r\n                System.out.println(\"erro na thread para atualizacao assincrona\");\r\n            }\r\n\r\n            multicastSocket.close();\r\n        }\r\n    }\r\n\r\n    //-------------------- VERIFICA LIGACAO -----------------\r\n    class VerificaLigacao extends TimerTask {\r\n        @Override\r\n        public void run() {\r\n            contagem++;\r\n            if (contagem == TEMPO_MAXIMO && logado.getValue().equals(\"ENTRADA\")) {\r\n                setLogado(\"EXCEDEU_TEMPO\");\r\n                termina();\r\n            }\r\n        }\r\n    }\r\n\r\n//-------------------------------------------------------------\r\n\r\n    public ProgramaCliente() {\r\n        logado.addListener(observable -> verificacaoLigacao());\r\n        logado.set(\"ENTRADA\");\r\n    }\r\n\r\n    private void termina() {\r\n        terminou = true;\r\n        temporizador.cancel();\r\n        tarefa.cancel();\r\n        logado.removeListener(observable -> verificacaoLigacao());\r\n        try {\r\n            if (socket != null)\r\n                socket.close();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    private void verificacaoLigacao() {\r\n        switch (logado.getValue()) {\r\n            case \"ENTRADA\" -> {\r\n                tarefa = new VerificaLigacao();\r\n                temporizador.schedule(tarefa, 0, 1000);\r\n            }\r\n            case \"SAIR\", \"FIM\" -> {\r\n                if (!terminou)\r\n                    termina();\r\n            }\r\n            case \"ADMINISTRADOR\", \"UTILIZADOR\" -> {\r\n                tarefa.cancel();\r\n                contagem = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////\r\n    public void addLogadoListener(InvalidationListener listener) {\r\n        logado.addListener(listener);\r\n    }\r\n\r\n    public void addAtualizacaoListener(InvalidationListener listener) {\r\n        atualizacao.addListener(listener);\r\n    }\r\n\r\n    public void addErroListener(InvalidationListener listener) {\r\n        erro.addListener(listener);\r\n    }\r\n\r\n    protected static synchronized void setErro() {\r\n        erro.set(erro.getValue() + 1);\r\n    }\r\n\r\n    public static synchronized void setLogado(String valor) {\r\n        logado.set(valor);\r\n    }\r\n\r\n    public String getLogado() {\r\n        return logado.getValue();\r\n    }\r\n\r\n    public boolean verificaFormato(String email) {\r\n        if (email == null || email.isBlank())\r\n            return true;\r\n        if (email.indexOf('@') <= 0 || !(email.indexOf('@') <= email.indexOf('.') - 2))\r\n            return true;\r\n        return email.split(\"[@.]\").length != 3;\r\n    }\r\n\r\n    /////////////////////////////////// FUNCIONALIDADES: ////////////////////////////////\r\n\r\n    /*---------------------------------- COMUNS: --------------------------------------*/\r\n    public Pair<Boolean, String> criaSocket(List<String> list) {\r\n        Pair<Boolean, String> pontoSituacao = new Pair<>(false, \"Erro na criação do socket\");\r\n        if (list.size() == 2) {\r\n            try {\r\n                portoServidor = Integer.parseInt(list.get(1));\r\n                InetAddress ip = InetAddress.getByName(list.get(0));\r\n                socket = new Socket(ip, portoServidor);\r\n                if (socket.isConnected()) {\r\n                    oin = new ObjectInputStream(socket.getInputStream());\r\n                    oout = new ObjectOutputStream(socket.getOutputStream());\r\n                    pontoSituacao = new Pair<>(true, \"Conexão bem sucedida\");\r\n                }\r\n            } catch (IllegalArgumentException e) {\r\n                pontoSituacao = new Pair<>(false, \"Introduziu um porto inválido.\");\r\n            } catch (NullPointerException e) {\r\n                pontoSituacao = new Pair<>(false, \"Introduziu um endereço inválido.\");\r\n            } catch (IOException e) {\r\n                pontoSituacao = new Pair<>(false, \"Ocorreu uma exceção I/O na criação do socket.\");\r\n            }\r\n        } else\r\n            pontoSituacao = new Pair<>(false, \"Não foram introduzidos dados suficientes como argumento.\");\r\n        return pontoSituacao;\r\n    }\r\n\r\n    public String login(String email, String password) {\r\n\r\n        if (password == null || password.isBlank() || verificaFormato(email))\r\n            return \"Tem que preencher os dados corretamente!!\";\r\n\r\n        Msg_Login dadosLogin = new Msg_Login(email, password);\r\n        try\r\n        {\r\n            oout.writeObject(dadosLogin);\r\n            oout.flush();\r\n\r\n            Object validacao = oin.readObject();\r\n\r\n            if(validacao instanceof Geral g){\r\n                if(g.getTipo() == Message_types.INVALIDO){\r\n                    return \"Não está registado na app :(\";\r\n                }\r\n                logado.set(g.getTipo() == Message_types.ADMINISTRADOR ? \"ADMINISTRADOR\" : \"UTILIZADOR\");\r\n\r\n                try{\r\n                    new Thread(new AtualizacaoAsync(portoServidor, ((Msg_String) g).getConteudo())).start();\r\n                    return \"Estabeleceu ligação!!\";\r\n                } catch (Exception e) {\r\n                    setErro();\r\n                    setLogado(\"FIM\");\r\n                }\r\n            }\r\n        } catch (IOException | ClassNotFoundException e) {\r\n            setErro();\r\n            setLogado(\"FIM\");\r\n        }\r\n        return \"Tente novamente...\";\r\n    }\r\n\r\n    public void logout() {\r\n        if (logado.getValue().equals(\"ADMINISTRADOR\") || logado.getValue().equals(\"UTILIZADOR\")) {\r\n\r\n            Geral logout = new Geral(Message_types.LOGOUT);\r\n            try {\r\n                oout.writeObject(logout);\r\n                oout.flush();\r\n                logado.set(\"ENTRADA\");\r\n            } catch (IOException e) {\r\n                setErro();\r\n            }\r\n            logado.set(\"ENTRADA\");\r\n        }\r\n    }\r\n\r\n    public Evento[] obterListaConsultaEventos(Message_types tipo, String nome, String local, LocalDate limData1, LocalDate limData2, int horaInicio, int horaFim) {\r\n        return new Evento[]{new Evento(\"ola\", \"HelloMate\", LocalDate.now(), 11, 12)};\r\n/*\r\n        if(nome != null && !nome.isBlank() && local != null && !local.isBlank() && limData1 != null && limData2 != null && horaInicio >= horaFim) {\r\n            Msg_ConsultaComFiltros consultaEventos = new Msg_ConsultaComFiltros(tipo, nome, local, limData1, limData2, horaInicio, horaFim);\r\n\r\n            try {\r\n                oout.writeObject(consultaEventos);\r\n                oout.flush();\r\n\r\n                Object lista = oin.readObject();\r\n                if(lista instanceof Geral l && l.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return null;\r\n                if (lista instanceof Msg_ListaEventos l && l.getTipo() == Message_types.VALIDO)\r\n                    return l.getLista();\r\n            } catch (IOException | ClassNotFoundException e) {\r\n                setErro();\r\n            }\r\n        }\r\n        return new Evento[]{};*/\r\n    }\r\n\r\n    public String obterCSV(String caminhoCSV, String nomeFicheiro, Message_types tipoCSV) {\r\n        if (caminhoCSV == null || caminhoCSV.isBlank() || nomeFicheiro == null || nomeFicheiro.isBlank())\r\n            return \"É necessário inserir um caminho para guardar o ficheiro!\";\r\n\r\n        String localCSVCaminho;\r\n        File destinoCSV = new File(caminhoCSV);\r\n        byte[] fileChunk = new byte[4000];\r\n        int nbytes;\r\n\r\n        if (!destinoCSV.exists()) {\r\n            return \"A directoria inserida [\" + caminhoCSV + \"] não existe!\";\r\n        }\r\n\r\n        if (!destinoCSV.isDirectory()) {\r\n            return \"O caminho [\" + caminhoCSV + \"] não é uma diretoria!\";\r\n        }\r\n\r\n        if (!destinoCSV.canWrite()) {\r\n            return \"Não pode guardar o .csv em: \" + destinoCSV;\r\n        }\r\n\r\n        try {\r\n            localCSVCaminho = destinoCSV.getCanonicalPath() + File.separator + nomeFicheiro + \".csv\";\r\n        } catch (IOException e) {\r\n            return \"Ocorreu um erro ao gerar o csv!\";\r\n        }\r\n\r\n        Geral csv = new Geral(tipoCSV);\r\n\r\n        try (FileOutputStream localFileOutputStream = new FileOutputStream(localCSVCaminho)) {\r\n\r\n            oout.writeObject(csv);\r\n            oout.flush();\r\n\r\n            InputStream inStream = socket.getInputStream();\r\n\r\n            while ((nbytes = inStream.read(fileChunk)) > 0) {\r\n                localFileOutputStream.write(fileChunk, 0, nbytes);\r\n            }\r\n            return \"CSV gerado com sucesso guardado em: \" + localCSVCaminho;\r\n        } catch (IOException e) {\r\n            setErro();\r\n        }\r\n        return \"Erro ao gerar CSV\";\r\n    }\r\n\r\n\r\n    /*---------------------------------- UTILIZADOR: --------------------------------------*/\r\n    public Pair<String, Boolean> registarConta(String nome, String email, String numIdentificacao, String password, String confPass) {\r\n\r\n        if (nome == null || nome.isBlank() || password == null || password.isBlank() ||\r\n            confPass == null || confPass.isBlank() || !password.equals(confPass) ||\r\n            verificaFormato(email) || numIdentificacao == null || numIdentificacao.isBlank())\r\n            return new Pair<>(\"Os dados inseriados são inválidos :(\", false);\r\n\r\n        int numID;\r\n        try {\r\n            numID = Integer.parseInt(numIdentificacao);\r\n        } catch (NumberFormatException e) {\r\n            return new Pair<>(\"Insira um número de identificação válido!\", false);\r\n        }\r\n\r\n        Mgs_RegistarEditar_Conta dadosRegisto = new Mgs_RegistarEditar_Conta(nome, email, password, numID, Message_types.REGISTO);\r\n\r\n        try {\r\n            oout.writeObject(dadosRegisto);\r\n            oout.flush();\r\n\r\n            Object validacao = oin.readObject();\r\n\r\n            if(validacao instanceof Msg_String g) {\r\n                if (g.getTipo() != Message_types.INVALIDO) {\r\n                    logado.set(\"UTILIZADOR\");\r\n                    try {\r\n                        new Thread(new AtualizacaoAsync(portoServidor, g.getConteudo())).start();\r\n                        return new Pair<>(\"\", true);\r\n                    } catch (Exception e) {\r\n                        setErro();\r\n                        setLogado(\"FIM\");\r\n                    }\r\n                }\r\n            }\r\n        } catch (IOException | ClassNotFoundException ignored) {\r\n            setErro();\r\n        }\r\n        return new Pair<>(\"Erro ao registar conta!\", false);\r\n    }\r\n\r\n    public String registarPresenca(String evento, String codigoEvento) {\r\n        if (evento == null || evento.isBlank() || codigoEvento == null || codigoEvento.isBlank())\r\n            return \"Tem de preencher os campos!!\";\r\n\r\n        try {\r\n            int codigo = Integer.parseInt(codigoEvento);\r\n            Msg_String_Int registoPresenca = new Msg_String_Int(evento, codigo, Message_types.SUBMICAO_COD);\r\n\r\n            try {\r\n                oout.writeObject(registoPresenca);\r\n                oout.flush();\r\n\r\n                Object validacao = oin.readObject();\r\n\r\n                if(validacao instanceof Geral l && l.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return \"Tem que fazer login para utilizar a app!\";\r\n                else if (validacao instanceof Geral g && g.getTipo() == Message_types.VALIDO)\r\n                        return \"Registou-se no evento com sucesso!\";\r\n            } catch (IOException | ClassNotFoundException ignored) {\r\n                setErro();\r\n            }\r\n        } catch (NumberFormatException ignored) {\r\n            return \"O código deve ser numérico!\";\r\n        }\r\n        return \"Erro...\";\r\n    }\r\n\r\n    public String editarRegisto(String nome, String numIdentificacao, String password, String confPass) {\r\n        if (nome == null || nome.isBlank() || password == null || password.isBlank() || !password.equals(confPass) || numIdentificacao == null || numIdentificacao.isBlank())\r\n            return \"Dados de input inválidos :(\";\r\n\r\n        int numID;\r\n        try {\r\n            numID = Integer.parseInt(numIdentificacao);//?? como é que ponho para long?\r\n            if (numID < 0)\r\n                return \"O teu número acho que não é negativo...\";\r\n\r\n            Mgs_RegistarEditar_Conta dadosRegisto = new Mgs_RegistarEditar_Conta(nome, null, password, numID, Message_types.EDITAR_REGISTO);\r\n\r\n            oout.writeObject(dadosRegisto);\r\n            oout.flush();\r\n\r\n            Object validacao = oin.readObject();\r\n            if(validacao instanceof Geral g) {\r\n                if (g.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return \"Tem que fazer login para utilizar a app!\";\r\n                else if (g.getTipo() == Message_types.VALIDO)\r\n                    return \"Registo editado com sucesso!\";\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            return \"O teu número deve ser inteiro!\";\r\n        } catch (ClassNotFoundException | IOException ignored) {\r\n            setErro();\r\n        }\r\n        return \"Erro\";\r\n    }\r\n\r\n\r\n    /*---------------------------------- ADMINISTRADOR: --------------------------------------*/\r\n    public String criar_Evento(String nome, String local, LocalDate data, int horaInicio, int horaFim) {\r\n        if (nome == null || nome.isBlank() || local == null || local.isBlank() || data == null || horaInicio >= horaFim)\r\n            return \"Dados de input inválidos :(\";\r\n\r\n        LocalDate dataAtual = LocalDate.now();\r\n        LocalTime horaAtual = LocalTime.now();\r\n\r\n        if (data.isBefore(dataAtual) || horaInicio < horaAtual.getHour())\r\n            return \"A data não pode estar no passadooo!\";\r\n\r\n        Msg_Cria_Evento evento = new Msg_Cria_Evento(new Evento(nome, local, data, horaInicio, horaFim));\r\n\r\n        try {\r\n            oout.writeObject(evento);\r\n            oout.flush();\r\n\r\n            Object validacao = oin.readObject();\r\n\r\n            if(validacao instanceof Geral g) {\r\n                if (g.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return \"Tem que fazer login para utilizar a app!\";\r\n                else if (g.getTipo() == Message_types.VALIDO)\r\n                    return \"Evento criado com sucesso!\";\r\n            }\r\n        } catch (IOException | ClassNotFoundException ignored) {\r\n            setErro();\r\n        }\r\n        return \"Erro\";\r\n    }\r\n\r\n    public String editar_Evento(String eventoNomeAntigo, String novoNome, String local, LocalDate data, int horaInicio, int horaFim) {\r\n\r\n        LocalDate dataAtual = LocalDate.now();\r\n        LocalTime horaAtual = LocalTime.now();\r\n\r\n        if (eventoNomeAntigo == null || eventoNomeAntigo.isBlank() || novoNome == null || novoNome.isBlank() ||\r\n                local == null || local.isBlank() || data == null || data.isBefore(dataAtual) ||\r\n                horaInicio < horaAtual.getHour() || horaInicio >= horaFim)\r\n            return \"Dados inválidos para criação de evento!\";\r\n\r\n        Msg_Edita_Evento evento = new Msg_Edita_Evento(new Evento(eventoNomeAntigo, local, data, horaInicio, horaFim), novoNome);\r\n\r\n        try {\r\n            oout.writeObject(evento);\r\n            oout.flush();\r\n\r\n            Object validacao = oin.readObject();\r\n\r\n            if(validacao instanceof Geral g) {\r\n                if (g.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return \"Tem que fazer login para utilizar a app!\";\r\n                else if (g.getTipo() == Message_types.VALIDO)\r\n                    return \"Evento editado com sucesso!\";\r\n            }\r\n        } catch (IOException | ClassNotFoundException ignored) {\r\n            setErro();\r\n        }\r\n        return \"Evento não editado!\";\r\n    }\r\n\r\n    public String eliminarEvento(String eventoNome) {\r\n        if (eventoNome == null || eventoNome.isBlank())\r\n            return \"Evento inexistente...\";\r\n\r\n        Msg_String evento = new Msg_String(eventoNome, Message_types.ELIMINAR_EVENTO);\r\n\r\n        try {\r\n            oout.writeObject(evento);\r\n            oout.flush();\r\n\r\n            Object validacao = oin.readObject();\r\n\r\n            if(validacao instanceof Geral g) {\r\n                if (g.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return \"Tem que fazer login para utilizar a app!\";\r\n                else if (g.getTipo() == Message_types.VALIDO)\r\n                    return \"Evento eliminado com sucesso!\";\r\n            }\r\n        } catch (IOException | ClassNotFoundException ignored) {\r\n            setErro();\r\n        }\r\n        return \"Evento não eliminado!\";\r\n    }\r\n\r\n    public String eliminaInserePresencas_Eventos(Message_types tipo, String evento, String emailsP) {\r\n        if (evento == null || evento.isBlank() || emailsP == null || emailsP.length() == 0 || emailsP.isBlank())\r\n            return \"Não foram inseridos emails!\";\r\n\r\n        ArrayList<String> emails = new ArrayList<>();\r\n        for (String email : emailsP.trim().split(\" \")) {\r\n            if (!verificaFormato(email))\r\n                emails.add(email);\r\n        }\r\n\r\n        Msg_EliminaInsere_Presencas interacao = new Msg_EliminaInsere_Presencas(tipo, evento, emails.toArray(new String[0]));\r\n\r\n        try {\r\n            oout.writeObject(interacao);\r\n            oout.flush();\r\n\r\n            Object validacao = oin.readObject();\r\n\r\n            if(validacao instanceof Geral g) {\r\n                if (g.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return \"Tem que fazer login para utilizar a app!\";\r\n                else if (g.getTipo() == Message_types.VALIDO)\r\n                    return tipo == Message_types.ELIMINA_PRES ? \"Presenças eliminadas com sucesso!\" : \"Presenças inseridas com sucesso!\";\r\n            }\r\n        } catch (IOException | ClassNotFoundException ignored) {\r\n            setErro();\r\n        }\r\n        return \"Tente novamente!\";\r\n    }\r\n\r\n    public String gerarCodPresenca(String evento, String tempoValido) {\r\n        if (evento == null || evento.isBlank())\r\n            return \"Evento inexistente...\";\r\n        if (tempoValido == null || tempoValido.isBlank())\r\n            return \"Insira o tempo de validade!\";\r\n\r\n        int tempo;\r\n        try {\r\n            tempo = Integer.parseInt(tempoValido);\r\n            if (tempo < 0)\r\n                return \"O tempo não pode ser negativo!\";\r\n        } catch (NumberFormatException e) {\r\n            return \"Tempo deve ser numérico!\";\r\n        }\r\n\r\n        Msg_String_Int geraCod = new Msg_String_Int(evento, tempo, Message_types.GERAR_COD);\r\n\r\n        try {\r\n            oout.writeObject(geraCod);\r\n            oout.flush();\r\n\r\n            Object codigo = oin.readObject();\r\n\r\n            if(codigo instanceof Geral g && g.getTipo() == Message_types.FAZER_lOGIN)\r\n                return \"Tem que fazer login pra usufruir da app!\";\r\n            if (codigo instanceof Msg_String cod && cod.getTipo() == Message_types.VALIDO) {\r\n                return cod.getConteudo();\r\n            }\r\n        } catch (IOException | ClassNotFoundException ignored) {\r\n            setErro();\r\n        }\r\n        return \"Erro\";\r\n    }\r\n\r\n    public Utilizador[] consultaPresencasEvento(String evento) {\r\n        if (evento != null && !evento.isBlank()) {\r\n\r\n            Msg_String consulta = new Msg_String(evento, Message_types.CONSULTA_PRES_EVENT);\r\n\r\n            try {\r\n                oout.writeObject(consulta);\r\n                oout.flush();\r\n\r\n                Object lista = oin.readObject();\r\n\r\n                if(lista instanceof Geral g && g.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return null;\r\n                if (lista instanceof Msg_ListaRegistos l && l.getTipo() == Message_types.VALIDO)\r\n                    return l.getLista();\r\n            } catch (IOException | ClassNotFoundException ignored) {\r\n                setErro();\r\n            }\r\n        }\r\n        return new Utilizador[]{};\r\n    }\r\n\r\n    public Evento[] consultaEventosDeUmUtilizador(String utilizador) {\r\n        if (!verificaFormato(utilizador)) {\r\n            Msg_String consulta = new Msg_String(utilizador, Message_types.CONSULTA_PRES_UTILIZADOR);\r\n            try {\r\n                oout.writeObject(consulta);\r\n                oout.flush();\r\n\r\n                Object lista = oin.readObject();\r\n                if(lista instanceof Geral g && g.getTipo() == Message_types.FAZER_lOGIN)\r\n                    return null;\r\n                if (lista instanceof Msg_ListaEventos l && l.getTipo() == Message_types.VALIDO)\r\n                    return l.getLista();\r\n            } catch (IOException | ClassNotFoundException e) {\r\n                setErro();\r\n            }\r\n        }\r\n        return new Evento[]{};\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../TP_PD_cliente_m1/src/pt/isec/pd/trabalhoPratico/model/classesPrograma/ProgramaCliente.java b/../TP_PD_cliente_m1/src/pt/isec/pd/trabalhoPratico/model/classesPrograma/ProgramaCliente.java
--- a/../TP_PD_cliente_m1/src/pt/isec/pd/trabalhoPratico/model/classesPrograma/ProgramaCliente.java	
+++ b/../TP_PD_cliente_m1/src/pt/isec/pd/trabalhoPratico/model/classesPrograma/ProgramaCliente.java	
@@ -17,7 +17,7 @@
 ///////////////////////////////////// PROGRAMA CLIENTE ///////////////////////
 public class ProgramaCliente {
     // TEMPO
-    private static final int TEMPO_MAXIMO = 20; // 10 segundos
+    private static final int TEMPO_MAXIMO = 60; // 10 segundos
     private final Timer temporizador = new Timer();
     private int contagem = 0;
     private TimerTask tarefa;
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" default=\"true\" project-jdk-name=\"20\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	
+++ b/.idea/misc.xml	
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_X" default="true" project-jdk-name="20" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_20" default="true" project-jdk-name="20" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
